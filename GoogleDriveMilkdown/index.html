<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Milkdown Drive Editor</title>
    <link rel="stylesheet" href="https://code.jquery.com/qunit/qunit-2.20.0.css">

    <!-- Google Identity & API -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>

    <style>
        :root {
            --sidebar-width: 300px;
            --primary: #4285F4;
            --border: #e0e0e0;
            --bg: #f8f9fa;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        #sidebar {
            width: var(--sidebar-width);
            background: #fff;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        #auth-section {
            padding: 20px;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
            text-align: center;
        }

        #setup-section {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #fff;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .setup-card {
            padding: 30px;
            border: 1px solid var(--border);
            border-radius: 8px;
            width: 400px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .setup-field {
            margin-bottom: 15px;
            text-align: left;
        }

        .setup-field label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .setup-field input {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        #file-search {
            padding: 10px;
            border-bottom: 1px solid var(--border);
        }

        #file-search input {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        #file-list {
            flex-grow: 1;
            overflow-y: auto;
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #file-list li {
            padding: 10px 20px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.9em;
        }

        #file-list li:hover {
            background-color: #f0f0f0;
        }

        #file-list li.active {
            background-color: #e8f0fe;
            color: var(--primary);
            font-weight: 600;
        }

        /* Main Editor */
        #main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #fff;
        }

        #toolbar {
            padding: 10px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            height: 40px;
        }

        #editor-wrapper {
            flex-grow: 1;
            overflow-y: auto;
            position: relative;
        }

        /* Milkdown Overrides */
        .milkdown .editor {
            padding: 40px 60px;
            max-width: 900px;
            margin: 0 auto;
            /* Ensure editor takes full height inside wrapper */
            min-height: calc(100vh - 100px);
        }

        /* Components */
        .btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-text {
            background: none;
            color: #666;
            margin-top: 10px;
            font-size: 0.8em;
            text-decoration: underline;
        }

        .status-badge {
            font-size: 0.85em;
            padding: 4px 8px;
            border-radius: 12px;
            background: #eee;
            color: #666;
        }

        .status-badge.saving {
            background: #fff3e0;
            color: #e65100;
        }

        .status-badge.saved {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status-badge.error {
            background: #ffebee;
            color: #c62828;
        }

        /* Testing Mode */
        #qunit,
        #qunit-fixture {
            display: none;
        }

        body.testing {
            flex-direction: column;
            overflow: auto;
        }

        body.testing #sidebar,
        body.testing #main {
            height: auto;
            border: 1px solid red;
            margin: 10px;
            width: auto;
        }

        body.testing #setup-section {
            display: none !important;
        }

        body.testing #qunit,
        body.testing #qunit-fixture {
            display: block;
            padding: 20px;
        }
    </style>
</head>

<body>

    <!-- Setup Section (Initial State) -->
    <div id="setup-section" style="display: none;">
        <div class="setup-card">
            <h2 style="margin-top:0;">Setup Google Drive Access</h2>
            <p style="color:#666; font-size:0.9em; margin-bottom:20px;">
                Enter your Google Cloud Project credentials. <br>
                These are stored locally in your browser.
            </p>

            <div class="setup-field">
                <label>Client ID</label>
                <input type="text" id="setup_client_id" placeholder="...apps.googleusercontent.com">
            </div>

            <div class="setup-field">
                <label>API Key</label>
                <input type="text" id="setup_api_key" placeholder="AIza...">
            </div>

            <button class="btn" onclick="saveConfig()">Save & Continue</button>
        </div>
    </div>

    <div id="sidebar">
        <div id="auth-section">
            <h2>Drive Editor</h2>
            <button id="authorize_button" class="btn" onclick="handleAuthClick()">Authorize Drive</button>
            <button id="signout_button" class="btn" onclick="handleSignoutClick()"
                style="display: none; background-color: #dc3545;">Sign Out</button>

            <div>
                <button class="btn btn-text" onclick="resetConfig()">Reset Credentials</button>
            </div>
        </div>
        <div id="file-search">
            <input type="text" id="search_input" placeholder="Search .md files..." disabled>
        </div>
        <ul id="file-list">
            <!-- Files will appear here -->
            <li style="padding:20px; color:#999; text-align:center;">Please login to view files</li>
        </ul>
    </div>

    <div id="main">
        <div id="toolbar">
            <span id="current-filename" style="font-weight:600;">Welcome</span>
            <span id="save-status" class="status-badge">Ready</span>
        </div>
        <div id="editor-wrapper">
            <div id="app"></div>
        </div>
    </div>

    <!-- QUnit -->
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
    <script src="https://code.jquery.com/qunit/qunit-2.20.0.js"></script>

    <!-- App Logic -->
    <script type="module">
        import { Editor, rootCtx, defaultValueCtx, editorViewOptionsCtx } from 'https://esm.sh/@milkdown/core@7.3.2';
        import { commonmark } from 'https://esm.sh/@milkdown/preset-commonmark@7.3.2?deps=@milkdown/core@7.3.2';
        import { nord } from 'https://esm.sh/@milkdown/theme-nord@7.3.2?deps=@milkdown/core@7.3.2';
        import { listener, listenerCtx } from 'https://esm.sh/@milkdown/plugin-listener@7.3.2?deps=@milkdown/core@7.3.2';

        /*******************************************************
         * CONFIGURATION
         *******************************************************/
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive';

        let CONFIG = {
            clientId: '',
            apiKey: ''
        };

        // --- App State ---
        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let currentFileId = null;
        let currentFrontmatter = ""; // Store stripped frontmatter here
        let editorInstance = null;
        let debounceTimer = null;
        let isSaving = false;

        // --- DOM Elements ---
        const authBtn = document.getElementById('authorize_button');
        const signoutBtn = document.getElementById('signout_button');
        const searchInput = document.getElementById('search_input');
        const fileList = document.getElementById('file-list');
        const fileNameSpan = document.getElementById('current-filename');
        const statusSpan = document.getElementById('save-status');
        const setupSection = document.getElementById('setup-section');
        const setupClientId = document.getElementById('setup_client_id');
        const setupApiKey = document.getElementById('setup_api_key');

        // --- Test Mode Check ---
        const urlParams = new URLSearchParams(window.location.search);
        const isTestMode = urlParams.get('test') === 'true';
        const testOverrides = {}; // For mocking in tests

        // --- Config Management ---
        function loadConfig() {
            if (isTestMode) {
                // Mock config for testing
                CONFIG.clientId = 'mock-client-id';
                CONFIG.apiKey = 'mock-api-key';
                return true;
            }

            const stored = localStorage.getItem('drive_editor_config');
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    if (parsed.clientId && parsed.apiKey) {
                        CONFIG = parsed;
                        return true;
                    }
                } catch (e) {
                    console.error('Invalid config', e);
                }
            }
            return false;
        }

        window.saveConfig = () => {
            const clientId = setupClientId.value.trim();
            const apiKey = setupApiKey.value.trim();

            if (!clientId || !apiKey) {
                alert('Please enter both Client ID and API Key');
                return;
            }

            const newConfig = { clientId, apiKey };
            localStorage.setItem('drive_editor_config', JSON.stringify(newConfig));
            // Reload to init
            window.location.reload();
        }

        window.resetConfig = () => {
            if (confirm('Are you sure you want to remove your credentials?')) {
                localStorage.removeItem('drive_editor_config');
                window.location.reload();
            }
        }

        // Initialize Call
        if (!loadConfig()) {
            setupSection.style.display = 'flex';
        }

        // --- Prefetching / Caching ---
        // Map<fileId, Promise<{body: string, frontmatter: string, imageMap: Map}>>
        const fileCache = new Map();

        async function prefetchFiles(files) {
            // Safety check for tests: if mocks aren't ready, don't prefetch
            if (isTestMode && (!testOverrides.getFileMeta || !testOverrides.getFile)) {
                return;
            }

            // Take top 20 files
            const toPrefetch = files.slice(0, 20);

            toPrefetch.forEach(file => {
                if (fileCache.has(file.id)) return; // Already cached or fetching

                console.log(`[Prefetch] Starting ${file.name}`);

                // Store promise immediately to prevent duplicate fetches
                const fetchPromise = (async () => {
                    try {
                        // Parallel fetch: Metadata (for parents) + Content
                        const [metaResp, contentResp] = await Promise.all([
                            (isTestMode && testOverrides.getFileMeta)
                                ? testOverrides.getFileMeta(file.id)
                                : gapi.client.drive.files.get({ fileId: file.id, fields: 'parents, name' }),
                            (isTestMode && testOverrides.getFile)
                                ? testOverrides.getFile(file.id)
                                : gapi.client.drive.files.get({ fileId: file.id, alt: 'media' })
                        ]);

                        const meta = isTestMode ? metaResp : metaResp.result;
                        const fullText = isTestMode ? contentResp.body : contentResp.body;

                        const { frontmatter, body } = parseFrontmatter(fullText);

                        // Resolve Images
                        let parentId = (meta.parents && meta.parents.length > 0) ? meta.parents[0] : null;
                        let displayBody = body;

                        // Use a local map for this file
                        const fileImageMap = new Map();
                        if (parentId) {
                            displayBody = await resolveImages(body, parentId, fileImageMap);
                        }

                        return {
                            body: displayBody,
                            frontmatter: frontmatter,
                            imageMap: fileImageMap
                        };
                    } catch (err) {
                        console.warn(`[Prefetch] Failed ${file.name}`, err);
                        fileCache.delete(file.id); // Remove failed promise so we can retry later
                        throw err;
                    }
                })();

                fileCache.set(file.id, fetchPromise);
            });
        }

        /*******************************************************
         * I. GOOGLE DRIVE API
         *******************************************************/

        // 1. Initialization
        window.handleAuthClick = () => {
            if (isTestMode && testOverrides.handleAuthClick) return testOverrides.handleAuthClick();

            if (!CONFIG.clientId) {
                console.error("Config missing");
                return;
            }

            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                updateSigninStatus(true);
                await listRecentFiles();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({ prompt: 'consent' });
            } else {
                tokenClient.requestAccessToken({ prompt: '' });
            }
        }

        window.handleSignoutClick = () => {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                updateSigninStatus(false);
            }
        }

        async function gapiLoaded() {
            if (isTestMode) return;
            if (!CONFIG.apiKey) return; // Wait for config

            gapi.load('client', async () => {
                await gapi.client.init({
                    apiKey: CONFIG.apiKey,
                    discoveryDocs: [DISCOVERY_DOC],
                });
                gapiInited = true;
                maybeEnableButtons();
            });
        }

        async function gisLoaded() {
            if (isTestMode) return;
            if (!CONFIG.clientId) return; // Wait for config

            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CONFIG.clientId,
                scope: SCOPES,
                callback: '', // defined later
            });
            gisInited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                authBtn.style.display = 'inline-block';
            }
        }

        // Expose to global scope for script onload callbacks
        window.gapiLoaded = gapiLoaded;
        window.gisLoaded = gisLoaded;

        // If scripts loaded before this runs (unlikely but possible)
        if (typeof gapi !== 'undefined') gapiLoaded();
        if (typeof google !== 'undefined') gisLoaded();

        function updateSigninStatus(isSignedIn) {
            if (isSignedIn) {
                authBtn.style.display = 'none';
                signoutBtn.style.display = 'inline-block';
                searchInput.disabled = false;
                fileList.innerHTML = '<li style="padding:20px; color:#999; text-align:center;">Loading files...</li>';
            } else {
                authBtn.style.display = 'inline-block';
                signoutBtn.style.display = 'none';
                searchInput.disabled = true;
                fileList.innerHTML = '<li style="padding:20px; color:#999; text-align:center;">Please login to view files</li>';
                destroyEditor();
            }
        }

        // 2. Drive Operations
        async function listRecentFiles(queryTerm = "") {
            try {
                let q = "name contains '.md' and trashed = false";
                if (queryTerm) {
                    q += ` and name contains '${queryTerm}'`;
                }

                // Mockable response
                const response = (isTestMode && testOverrides.listFiles)
                    ? await testOverrides.listFiles(q)
                    : await gapi.client.drive.files.list({
                        'pageSize': 20,
                        'fields': 'files(id, name, modifiedTime)',
                        'orderBy': 'modifiedTime desc',
                        'q': q
                    });

                const files = response.result.files;
                renderFileList(files);
            } catch (err) {
                console.error('Error listing files', err);
                fileList.innerHTML = `<li style="color:red; padding:10px;">Error loading files: ${err.message}</li>`;
            }
        }

        async function loadDriveFile(fileId, fileName) {
            setStatus('loading', 'Loading...');
            try {
                // Initialize Editor (Destroy first)
                await destroyEditor();

                // Initialize clean global image map for this session
                imageMap = new Map();

                let loadedData;

                // --- CACHE CHECK ---
                if (fileCache.has(fileId)) {
                    console.log(`[Cache] Hit for ${fileName}`);
                    loadedData = await fileCache.get(fileId);
                } else {
                    console.log(`[Cache] Miss for ${fileName}, fetching...`);
                    // Parallel fetch: Metadata (for parents) + Content
                    const [metaResp, contentResp] = await Promise.all([
                        (isTestMode && testOverrides.getFileMeta)
                            ? testOverrides.getFileMeta(fileId)
                            : gapi.client.drive.files.get({ fileId: fileId, fields: 'parents, name' }),
                        (isTestMode && testOverrides.getFile)
                            ? testOverrides.getFile(fileId)
                            : gapi.client.drive.files.get({ fileId: fileId, alt: 'media' })
                    ]);

                    const meta = isTestMode ? metaResp : metaResp.result;
                    const fullText = isTestMode ? contentResp.body : contentResp.body;

                    const { frontmatter, body } = parseFrontmatter(fullText);

                    // Resolve Images
                    let parentId = (meta.parents && meta.parents.length > 0) ? meta.parents[0] : null;
                    let displayBody = body;
                    let fileImageMap = new Map();

                    if (parentId) {
                        setStatus('loading', 'Loading images...');
                        displayBody = await resolveImages(body, parentId, fileImageMap);
                    }

                    loadedData = {
                        body: displayBody,
                        frontmatter: frontmatter,
                        imageMap: fileImageMap
                    };

                    // Cache it now for future?
                    fileCache.set(fileId, Promise.resolve(loadedData));
                }

                // Apply Data
                currentFrontmatter = loadedData.frontmatter;
                currentFileId = fileId;
                imageMap = loadedData.imageMap; // Restore the specific map for this file

                // UI Updates
                fileNameSpan.textContent = fileName;
                setStatus('ready', 'Ready');

                await createEditor(loadedData.body);

                // Highlight active in list
                document.querySelectorAll('#file-list li').forEach(li => li.classList.remove('active'));
                const activeLi = document.getElementById(`file-${fileId}`);
                if (activeLi) activeLi.classList.add('active');

            } catch (err) {
                console.error(err);
                setStatus('error', 'Load Failed: ' + (err.result?.error?.message || err.message));
                fileCache.delete(fileId); // Validate cache on error
            }
        }

        async function saveDriveFile(content) {
            if (!currentFileId) return;

            isSaving = true;
            setStatus('saving', 'Saving...');

            try {
                // Restore original image paths
                const originalContent = restoreImages(content);

                // Re-attach frontmatter
                const finalContent = currentFrontmatter + originalContent;

                if (isTestMode && testOverrides.updateFile) {
                    await testOverrides.updateFile(currentFileId, finalContent);
                } else {
                    await gapi.client.request({
                        path: `/upload/drive/v3/files/${currentFileId}`,
                        method: 'PATCH',
                        params: { uploadType: 'media' },
                        body: finalContent
                    });
                }

                // Invalidate cache since content changed
                fileCache.delete(currentFileId);

                setStatus('saved', 'Saved to Drive');
            } catch (err) {
                console.error(err);
                setStatus('error', 'Save Failed');
            } finally {
                isSaving = false;
            }
        }

        // Helper to fetch blob (wrapper for easy mocking)
        async function fetchBlob(url, headers) {
            if (isTestMode && testOverrides.fetchBlob) {
                return testOverrides.fetchBlob(url, headers);
            }
            const resp = await fetch(url, { headers });
            if (!resp.ok) throw new Error('Fetch failed');
            return resp.blob();
        }

        // --- Image Handling Helpers ---
        let imageMap = new Map(); // blobUrl -> originalPath

        // Recursively find file ID by path (e.g. "Assets/img.png") starting from parentId
        async function findFileIdByPath(parentId, path) {
            const parts = path.split('/');
            let currentId = parentId;

            for (let i = 0; i < parts.length; i++) {
                const name = parts[i];
                if (!name || name === '.') continue;

                if (name === '..') {
                    // Fetch parent of currentId
                    try {
                        const resp = (isTestMode && testOverrides.getFileMeta)
                            ? await testOverrides.getFileMeta(currentId)
                            : await gapi.client.drive.files.get({
                                fileId: currentId,
                                fields: 'parents'
                            });

                        const meta = isTestMode ? resp : resp.result;
                        if (!meta.parents || meta.parents.length === 0) {
                            console.warn(`[MilkdownImage] Cannot traverse up from ${currentId}`);
                            return null;
                        }
                        currentId = meta.parents[0];
                        continue;
                    } catch (e) {
                        console.warn(`[MilkdownImage] Error traversing up from ${currentId}`, e);
                        return null;
                    }
                }

                const isLast = i === parts.length - 1;
                const safeName = name.replace(/'/g, "\\'");

                // For folders, we need distinct query? strictly speaking, files and folders are just files with mimeTypes.
                // But generally we just look for name and parent.
                const q = `'${currentId}' in parents and name = '${safeName}' and trashed = false`;

                const listResp = (isTestMode && testOverrides.listFiles)
                    ? await testOverrides.listFiles(q)
                    : await gapi.client.drive.files.list({
                        q: q,
                        fields: 'files(id, name, mimeType)',
                        pageSize: 1
                    });

                const files = listResp.result.files;
                if (!files || files.length === 0) {
                    console.warn(`[MilkdownImage] Path segment not found: ${name} in ${currentId}`);
                    return null;
                }

                // If duplicates, take first. Ideally prioritize folders if we are in middle of path.
                // If not lsast, we expect a folder.
                let match = files[0];
                if (!isLast) {
                    match = files.find(f => f.mimeType === 'application/vnd.google-apps.folder') || files[0];
                }

                currentId = match.id;
            }
            return currentId;
        }

        async function resolveImages(markdown, parentId, targetMap = null) {
            const mapToUse = targetMap || imageMap;
            if (!targetMap) imageMap.clear();

            const regex = /!\[([^\]]*)\]\(([^)]+)\)/g;
            let match;
            const updates = [];

            // 1. Find all local images
            while ((match = regex.exec(markdown)) !== null) {
                const [fullMatch, alt, src] = match;
                if (!src.startsWith('http') && !src.startsWith('data:')) {
                    updates.push({ fullMatch, alt, src });
                }
            }

            if (updates.length === 0) return markdown;

            // 2. Fetch blobs for each unique local image
            // We use a Set to avoid fetching same image twice
            const uniqueSrcs = [...new Set(updates.map(u => u.src))];
            const urlMap = {}; // src -> blobUrl

            console.log('[MilkdownImage] Resolving images in parent:', parentId, uniqueSrcs);
            if (!parentId) {
                console.warn('[MilkdownImage] No parent ID found, cannot resolve sibling images.');
                return markdown;
            }

            await Promise.all(uniqueSrcs.map(async (src) => {
                try {
                    // Resolve nested path
                    const fileId = await findFileIdByPath(parentId, src);

                    if (fileId) {
                        console.log(`[MilkdownImage] Found ${src} -> ${fileId}`);

                        // Fetch content as blob
                        const token = (isTestMode ? 'mock-token' : gapi.client.getToken().access_token);

                        const blob = await fetchBlob(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
                            'Authorization': `Bearer ${token}`
                        });

                        const blobUrl = URL.createObjectURL(blob);
                        urlMap[src] = blobUrl;
                        mapToUse.set(blobUrl, src);
                    } else {
                        console.warn(`[MilkdownImage] Image not found in Drive: ${src}`);
                    }
                } catch (e) {
                    console.warn(`[MilkdownImage] Failed to load image ${src}`, e);
                }
            }));

            // 3. Replace in markdown
            let newMarkdown = markdown;
            updates.forEach(({ fullMatch, alt, src }) => {
                if (urlMap[src]) {
                    const newTag = `![${alt}](${urlMap[src]})`;
                    newMarkdown = newMarkdown.split(fullMatch).join(newTag);
                }
            });

            return newMarkdown;
        }

        function restoreImages(markdown) {
            let newMarkdown = markdown;
            // Iterate map and replace blobUrls back to original
            for (const [blobUrl, originalSrc] of imageMap.entries()) {
                newMarkdown = newMarkdown.split(blobUrl).join(originalSrc);
            }
            return newMarkdown;
        }

        /*******************************************************
         * II. LOGIC & HELPERS
         *******************************************************/

        function renderFileList(files) {
            fileList.innerHTML = '';
            if (!files || files.length === 0) {
                fileList.innerHTML = '<li style="padding:20px; color:#999; text-align:center;">No Markdown files found.</li>';
                return;
            }

            files.forEach(file => {
                const li = document.createElement('li');
                li.id = `file-${file.id}`;
                li.textContent = file.name;
                li.onclick = () => loadDriveFile(file.id, file.name);
                fileList.appendChild(li);
            });

            // Trigger Prefetch (Top 5 visible)
            prefetchFiles(files);
        }

        // Basic Frontmatter Parser (YAML-like)
        // Looks for --- at start, then next ---
        function parseFrontmatter(text) {
            // Normalize newlines
            const normalized = text.replace(/\r\n/g, '\n');
            const match = normalized.match(/^---\n([\s\S]*?)\n---\n/);

            if (match) {
                return {
                    frontmatter: match[0], // Keep the whole block including delimiters
                    body: normalized.substring(match[0].length)
                };
            }
            return { frontmatter: "", body: normalized };
        }

        function setStatus(cls, text) {
            statusSpan.className = `status-badge ${cls}`;
            statusSpan.textContent = text;
        }

        // Debounce
        function debounce(func, wait) {
            return function (...args) {
                clearTimeout(debounceTimer);
                setStatus('saving', 'Unsaved changes...');
                debounceTimer = setTimeout(() => func.apply(this, args), wait);
            };
        }

        const debouncedSave = debounce((content) => {
            saveDriveFile(content);
        }, 2000); // 2 second delay

        // Search Listener
        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                fileList.innerHTML = '<li style="padding:20px; color:#999; text-align:center;">Searching...</li>';
                listRecentFiles(e.target.value);
            }, 500);
        });

        /*******************************************************
         * III. MILKDOWN EDITOR
         *******************************************************/

        async function createEditor(content) {
            if (isTestMode && testOverrides.createEditor) return testOverrides.createEditor(content);

            editorInstance = await Editor.make()
                .config((ctx) => {
                    ctx.set(rootCtx, document.querySelector('#app'));
                    ctx.set(defaultValueCtx, content);
                    ctx.set(editorViewOptionsCtx, { editable: () => true });

                    // Listener for autosave
                    ctx.get(listenerCtx).markdownUpdated((ctx, markdown) => {
                        // Only save if we have a file loaded
                        if (currentFileId) {
                            debouncedSave(markdown);
                        }
                    });
                })
                .use(nord)
                .use(commonmark)
                .use(listener)
                .create();
        }

        async function destroyEditor() {
            if (editorInstance) {
                document.querySelector('#app').innerHTML = '';
                editorInstance = null;
            }
            fileNameSpan.textContent = "";
            currentFileId = null;
            currentFrontmatter = "";
            setStatus('ready', '');
        }

        /*******************************************************
         * IV. TESTING (QUNIT)
         *******************************************************/
        if (isTestMode && window.QUnit) {
            document.body.classList.add('testing');

            QUnit.module('Frontmatter Logic', () => {
                QUnit.test('parseFrontmatter separates YAML from body', assert => {
                    const original = "---\ntitle: test\n---\n# Header\nContent";
                    const { frontmatter, body } = parseFrontmatter(original);
                    assert.equal(frontmatter.trim(), "---\ntitle: test\n---", "Frontmatter captured");
                    assert.equal(body.trim(), "# Header\nContent", "Body captured");
                });

                QUnit.test('parseFrontmatter handles no frontmatter', assert => {
                    const original = "# Just Content";
                    const { frontmatter, body } = parseFrontmatter(original);
                    assert.equal(frontmatter, "", "Empty frontmatter");
                    assert.equal(body, original, "Body matches original");
                });
            });

            QUnit.module('UI & List', hooks => {
                hooks.beforeEach(() => {
                    fileList.innerHTML = '';
                });

                QUnit.test('renderFileList creates list items', assert => {
                    const files = [
                        { id: '1', name: 'File1.md' },
                        { id: '2', name: 'File2.md' }
                    ];
                    renderFileList(files);
                    assert.equal(fileList.children.length, 2);
                    assert.equal(fileList.children[0].textContent, 'File1.md');
                });

                QUnit.test('renderFileList handles empty list', assert => {
                    renderFileList([]);
                    assert.ok(fileList.textContent.includes('No Markdown files'));
                });
            });

            QUnit.module('Drive Interaction', hooks => {
                let savedListFiles, savedGetFile, savedUpdateFile;

                hooks.beforeEach(() => {
                    savedListFiles = testOverrides.listFiles;
                    savedGetFile = testOverrides.getFile;
                    savedUpdateFile = testOverrides.updateFile;
                });

                hooks.afterEach(() => {
                    testOverrides.listFiles = savedListFiles;
                    testOverrides.getFile = savedGetFile;
                    testOverrides.updateFile = savedUpdateFile;
                    currentFileId = null;
                    if (debounceTimer) clearTimeout(debounceTimer);
                });

                QUnit.test('listRecentFiles calls API with correct query', async assert => {
                    const done = assert.async();
                    testOverrides.listFiles = async (q) => {
                        assert.ok(q.includes("name contains '.md'"), "Query filters for markdown");
                        assert.ok(q.includes("trashed = false"), "Query excludes trash");
                        done();
                        return { result: { files: [] } };
                    };
                    await listRecentFiles();
                });

                QUnit.test('loadDriveFile parses frontmatter and sets editor', async assert => {
                    const done = assert.async();
                    const mockId = '123';
                    const mockContent = "---\nmeta: true\n---\n# Body";

                    testOverrides.getFileMeta = async (id) => {
                        assert.equal(id, mockId);
                        return { result: { parents: ['folder1'], name: 'Test.md' } };
                    };

                    testOverrides.getFile = async (id) => {
                        assert.equal(id, mockId);
                        return { body: mockContent };
                    };

                    // Allow images to skip if no files found
                    testOverrides.listFiles = async () => ({ result: { files: [] } });

                    testOverrides.createEditor = async (content) => {
                        assert.equal(content, "# Body", "Editor received only body");
                        assert.equal(currentFrontmatter, "---\nmeta: true\n---\n", "Frontmatter stored globally");
                        done();
                    };

                    await loadDriveFile(mockId, 'Test.md');
                });

                QUnit.test('saveDriveFile re-attaches frontmatter', async assert => {
                    const done = assert.async();

                    // Setup internal state
                    currentFileId = '123';
                    currentFrontmatter = "---Header---\n";
                    const newContent = "New Body";

                    testOverrides.updateFile = async (id, content) => {
                        assert.equal(id, '123');
                        assert.equal(content, "---Header---\nNew Body", "Frontmatter prepended to update");
                        // check UI
                        assert.ok(statusSpan.className.includes('saving'), 'Status is saving during op');
                        done();
                    };

                    await saveDriveFile(newContent);
                    assert.ok(statusSpan.className.includes('saved'), 'Status becomes saved');
                });
            });

            QUnit.module('Image Handling', hooks => {
                hooks.beforeEach(() => {
                    imageMap = new Map();
                });

                QUnit.test('resolveImages replaces local paths with blobs', async assert => {
                    const done = assert.async();
                    const markdown = "![img1](test.png) ![img2](assets/icon.png)";
                    const mockParent = "folder123";

                    // Mock List API with nested logic
                    testOverrides.listFiles = async (q) => {
                        // 1. Root level test.png
                        if (q.includes(`'folder123' in parents`) && q.includes(`name = 'test.png'`)) {
                            return { result: { files: [{ id: 'file1', name: 'test.png' }] } };
                        }

                        // 2. assets folder search
                        if (q.includes(`'folder123' in parents`) && q.includes(`name = 'assets'`)) {
                            return { result: { files: [{ id: 'folder-assets', name: 'assets', mimeType: 'application/vnd.google-apps.folder' }] } };
                        }

                        // 3. icon.png in assets folder
                        if (q.includes(`'folder-assets' in parents`) && q.includes(`name = 'icon.png'`)) {
                            return { result: { files: [{ id: 'file-icon', name: 'icon.png' }] } };
                        }

                        return { result: { files: [] } };
                    };

                    // Mock Fetch
                    testOverrides.fetchBlob = async (url) => {
                        if (url.includes('files/file1') || url.includes('files/file-icon')) {
                            return new Blob(['fake-image']);
                        }
                        throw new Error("404");
                    };

                    // Stub createObjectURL
                    const originalCreateObjectUrl = URL.createObjectURL;
                    URL.createObjectURL = (blob) => "blob:test-url";

                    try {
                        const result = await resolveImages(markdown, mockParent);

                        // Check test.png
                        assert.ok(result.includes("![img1](blob:test-url)"), "img1 (flat) replaced");
                        // Check assets/icon.png
                        assert.ok(result.includes("![img2](blob:test-url)"), "img2 (nested) replaced");

                        // Verify Map
                        assert.equal(imageMap.get("blob:test-url"), "assets/icon.png", "Map stored correct reverse path for nested");

                    } finally {
                        URL.createObjectURL = originalCreateObjectUrl;
                        done();
                    }
                });

                QUnit.test('restoreImages reverts blobs to original paths', assert => {
                    imageMap.set("blob:abc", "original.png");
                    const input = "![test](blob:abc)";
                    const result = restoreImages(input);
                    assert.equal(result, "![test](original.png)");
                });
                QUnit.test('resolveImages handles parent traversal', async assert => {
                    const done = assert.async();
                    const markdown = "![img](../sibling/image.png)";
                    const startParent = "current-folder";

                    testOverrides.getFileMeta = async (id) => {
                        if (id === 'current-folder') return { parents: ['parent-folder'] };
                        return { parents: [] };
                    };

                    testOverrides.listFiles = async (q) => {
                        // finding sibling folder in parent
                        if (q.includes(`'parent-folder' in parents`) && q.includes(`name = 'sibling'`)) {
                            return { result: { files: [{ id: 'sibling-folder', name: 'sibling', mimeType: 'application/vnd.google-apps.folder' }] } };
                        }
                        // finding image in sibling folder
                        if (q.includes(`'sibling-folder' in parents`) && q.includes(`name = 'image.png'`)) {
                            return { result: { files: [{ id: 'target-file', name: 'image.png' }] } };
                        }
                        return { result: { files: [] } };
                    };

                    testOverrides.fetchBlob = async () => new Blob(['fake']);

                    const originalCreateObjectUrl = URL.createObjectURL;
                    URL.createObjectURL = () => "blob:test";

                    try {
                        const result = await resolveImages(markdown, startParent);
                        assert.ok(result.includes("(blob:test)"), "Parent path resolved");
                        assert.equal(imageMap.get("blob:test"), "../sibling/image.png");
                    } finally {
                        URL.createObjectURL = originalCreateObjectUrl;
                        done();
                    }
                });
            });

            QUnit.module('Prefetching & Caching', hooks => {
                hooks.beforeEach(() => {
                    fileCache.clear();
                    imageMap.clear();
                    currentFileId = null;
                    testOverrides.listFiles = async () => ({ result: { files: [] } });
                    testOverrides.getFile = async () => ({ body: "content" });
                    testOverrides.getFileMeta = async () => ({ result: { parents: ['parent'] } });
                    testOverrides.fetchBlob = async () => new Blob(['fake']);
                });

                QUnit.test('prefetchFiles populates cache', async assert => {
                    const done = assert.async();
                    const mockFiles = [{ id: 'f1', name: 'File 1' }, { id: 'f2', name: 'File 2' }];

                    // Mock getFile
                    testOverrides.getFile = async (id) => {
                        return { body: `Content of ${id}` };
                    };

                    await prefetchFiles(mockFiles);

                    assert.ok(fileCache.has('f1'), "Cache has File 1");
                    assert.ok(fileCache.has('f2'), "Cache has File 2");

                    // Wait for promises to resolve
                    const f1Data = await fileCache.get('f1');
                    assert.ok(f1Data.body.includes('Content of f1'), "Cache resolved correct content");

                    done();
                });

                QUnit.test('loadDriveFile uses cache if available', async assert => {
                    const done = assert.async();
                    const fileId = 'cached-file';

                    // Pre-seed cache
                    fileCache.set(fileId, Promise.resolve({
                        body: 'Cached Content',
                        frontmatter: '',
                        imageMap: new Map([['blob:url', 'img.png']])
                    }));

                    let fetchCalled = false;
                    testOverrides.getFile = async () => { fetchCalled = true; return { body: 'New Content' }; };

                    await loadDriveFile(fileId, 'Cached File');

                    assert.notOk(fetchCalled, "Did NOT fetch from Drive");
                    assert.equal(imageMap.get('blob:url'), 'img.png', "Global imageMap restored from cache");

                    done();
                });

                QUnit.test('saveDriveFile invalidates cache', async assert => {
                    const done = assert.async();
                    const fileId = 'save-file';
                    currentFileId = fileId;
                    currentFrontmatter = "";

                    // Pre-seed cache
                    fileCache.set(fileId, Promise.resolve({ body: 'Old', frontmatter: '', imageMap: new Map() }));

                    testOverrides.updateFile = async () => { }; // successful save

                    await saveDriveFile('New Content');

                    assert.notOk(fileCache.has(fileId), "Cache cleared after save");

                    done();
                });
            });
        }
    </script>
</body>

</html>