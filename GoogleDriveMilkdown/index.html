<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Milkdown Drive Editor</title>
    <link rel="stylesheet" href="https://code.jquery.com/qunit/qunit-2.20.0.css">

    <!-- Google Identity & API -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>

    <style>
        :root {
            --sidebar-width: 300px;
            --primary: #4285F4;
            --border: #e0e0e0;
            --bg: #f8f9fa;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        #sidebar {
            width: var(--sidebar-width);
            background: #fff;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        #auth-section {
            padding: 20px;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
            text-align: center;
        }

        #file-search {
            padding: 10px;
            border-bottom: 1px solid var(--border);
        }

        #file-search input {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        #file-list {
            flex-grow: 1;
            overflow-y: auto;
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #file-list li {
            padding: 10px 20px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.9em;
        }

        #file-list li:hover {
            background-color: #f0f0f0;
        }

        #file-list li.active {
            background-color: #e8f0fe;
            color: var(--primary);
            font-weight: 600;
        }

        /* Main Editor */
        #main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #fff;
        }

        #toolbar {
            padding: 10px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            height: 40px;
        }

        #editor-wrapper {
            flex-grow: 1;
            overflow-y: auto;
            position: relative;
        }

        /* Milkdown Overrides */
        .milkdown .editor {
            padding: 40px 60px;
            max-width: 900px;
            margin: 0 auto;
            /* Ensure editor takes full height inside wrapper */
            min-height: calc(100vh - 100px);
        }

        /* Components */
        .btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .status-badge {
            font-size: 0.85em;
            padding: 4px 8px;
            border-radius: 12px;
            background: #eee;
            color: #666;
        }

        .status-badge.saving {
            background: #fff3e0;
            color: #e65100;
        }

        .status-badge.saved {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status-badge.error {
            background: #ffebee;
            color: #c62828;
        }

        /* Testing Mode */
        #qunit,
        #qunit-fixture {
            display: none;
        }

        body.testing {
            flex-direction: column;
            overflow: auto;
        }

        body.testing #sidebar,
        body.testing #main {
            height: auto;
            border: 1px solid red;
            margin: 10px;
            width: auto;
        }

        body.testing #qunit,
        body.testing #qunit-fixture {
            display: block;
            padding: 20px;
        }
    </style>
</head>

<body>

    <div id="sidebar">
        <div id="auth-section">
            <h2>Drive Editor</h2>
            <button id="authorize_button" class="btn" onclick="handleAuthClick()">Authorize Drive</button>
            <button id="signout_button" class="btn" onclick="handleSignoutClick()"
                style="display: none; background-color: #dc3545;">Sign Out</button>
        </div>
        <div id="file-search">
            <input type="text" id="search_input" placeholder="Search .md files..." disabled>
        </div>
        <ul id="file-list">
            <!-- Files will appear here -->
            <li style="padding:20px; color:#999; text-align:center;">Please login to view files</li>
        </ul>
    </div>

    <div id="main">
        <div id="toolbar">
            <span id="current-filename" style="font-weight:600;">Welcome</span>
            <span id="save-status" class="status-badge">Ready</span>
        </div>
        <div id="editor-wrapper">
            <div id="app"></div>
        </div>
    </div>

    <!-- QUnit -->
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
    <script src="https://code.jquery.com/qunit/qunit-2.20.0.js"></script>

    <!-- App Logic -->
    <script type="module">
        import { Editor, rootCtx, defaultValueCtx, editorViewOptionsCtx } from 'https://esm.sh/@milkdown/core@7.3.2';
        import { commonmark } from 'https://esm.sh/@milkdown/preset-commonmark@7.3.2?deps=@milkdown/core@7.3.2';
        import { nord } from 'https://esm.sh/@milkdown/theme-nord@7.3.2?deps=@milkdown/core@7.3.2';
        import { listener, listenerCtx } from 'https://esm.sh/@milkdown/plugin-listener@7.3.2?deps=@milkdown/core@7.3.2';

        /*******************************************************
         * CONFIGURATION
         *******************************************************/
        const CLIENT_ID = '112047506162-5lphksopq4fss8hnh9jpdi8uk8805hoc.apps.googleusercontent.com'; // <--- REPLACE THIS
        const API_KEY = 'AIzaSyARvE4eIk7GSicDRN44tjw72YrUKVHPUpg';       // <--- REPLACE THIS
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive';

        // --- App State ---
        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let currentFileId = null;
        let currentFrontmatter = ""; // Store stripped frontmatter here
        let editorInstance = null;
        let debounceTimer = null;
        let isSaving = false;

        // --- DOM Elements ---
        const authBtn = document.getElementById('authorize_button');
        const signoutBtn = document.getElementById('signout_button');
        const searchInput = document.getElementById('search_input');
        const fileList = document.getElementById('file-list');
        const fileNameSpan = document.getElementById('current-filename');
        const statusSpan = document.getElementById('save-status');

        // --- Test Mode Check ---
        const urlParams = new URLSearchParams(window.location.search);
        const isTestMode = urlParams.get('test') === 'true';
        const testOverrides = {}; // For mocking in tests

        /*******************************************************
         * I. GOOGLE DRIVE API
         *******************************************************/

        // 1. Initialization
        window.handleAuthClick = () => {
            if (isTestMode && testOverrides.handleAuthClick) return testOverrides.handleAuthClick();
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                updateSigninStatus(true);
                await listRecentFiles();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({ prompt: 'consent' });
            } else {
                tokenClient.requestAccessToken({ prompt: '' });
            }
        }

        window.handleSignoutClick = () => {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                updateSigninStatus(false);
            }
        }

        async function gapiLoaded() {
            if (isTestMode) return;
            gapi.load('client', async () => {
                await gapi.client.init({
                    apiKey: API_KEY,
                    discoveryDocs: [DISCOVERY_DOC],
                });
                gapiInited = true;
                maybeEnableButtons();
            });
        }

        async function gisLoaded() {
            if (isTestMode) return;
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '', // defined later
            });
            gisInited = true;
            maybeEnableButtons();
        }

        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                authBtn.style.display = 'inline-block';
            }
        }

        // Expose to global scope for script onload callbacks
        window.gapiLoaded = gapiLoaded;
        window.gisLoaded = gisLoaded;

        // If scripts loaded before this runs (unlikely but possible)
        if (typeof gapi !== 'undefined') gapiLoaded();
        if (typeof google !== 'undefined') gisLoaded();

        function updateSigninStatus(isSignedIn) {
            if (isSignedIn) {
                authBtn.style.display = 'none';
                signoutBtn.style.display = 'inline-block';
                searchInput.disabled = false;
                fileList.innerHTML = '<li style="padding:20px; color:#999; text-align:center;">Loading files...</li>';
            } else {
                authBtn.style.display = 'inline-block';
                signoutBtn.style.display = 'none';
                searchInput.disabled = true;
                fileList.innerHTML = '<li style="padding:20px; color:#999; text-align:center;">Please login to view files</li>';
                destroyEditor();
            }
        }

        // 2. Drive Operations
        async function listRecentFiles(queryTerm = "") {
            try {
                let q = "name contains '.md' and trashed = false";
                if (queryTerm) {
                    q += ` and name contains '${queryTerm}'`;
                }

                // Mockable response
                const response = (isTestMode && testOverrides.listFiles)
                    ? await testOverrides.listFiles(q)
                    : await gapi.client.drive.files.list({
                        'pageSize': 20,
                        'fields': 'files(id, name, modifiedTime)',
                        'orderBy': 'modifiedTime desc',
                        'q': q
                    });

                const files = response.result.files;
                renderFileList(files);
            } catch (err) {
                console.error('Error listing files', err);
                fileList.innerHTML = `<li style="color:red; padding:10px;">Error loading files: ${err.message}</li>`;
            }
        }

        async function loadDriveFile(fileId, fileName) {
            setStatus('loading', 'Loading...');
            try {
                // Parallel fetch: Metadata (for parents) + Content
                // We mock these efficiently in tests
                const [metaResp, contentResp] = await Promise.all([
                    (isTestMode && testOverrides.getFileMeta)
                        ? testOverrides.getFileMeta(fileId)
                        : gapi.client.drive.files.get({ fileId: fileId, fields: 'parents, name' }),
                    (isTestMode && testOverrides.getFile)
                        ? testOverrides.getFile(fileId)
                        : gapi.client.drive.files.get({ fileId: fileId, alt: 'media' })
                ]);

                const meta = isTestMode ? metaResp : metaResp.result;
                const fullText = isTestMode ? contentResp.body : contentResp.body;

                // Initialize Editor (Destroy first)
                await destroyEditor();

                // --- FRONTMATTER HANDLING ---
                const { frontmatter, body } = parseFrontmatter(fullText);
                currentFrontmatter = frontmatter;
                currentFileId = fileId;

                // --- IMAGE HANDLING ---
                // We need the parent folder to look for sibling images
                let parentId = (meta.parents && meta.parents.length > 0) ? meta.parents[0] : null;

                let displayBody = body;
                if (parentId) {
                    setStatus('loading', 'Loading images...');
                    displayBody = await resolveImages(body, parentId);
                }

                // UI Updates
                fileNameSpan.textContent = fileName;
                setStatus('ready', 'Ready');

                await createEditor(displayBody);

                // Highlight active in list
                document.querySelectorAll('#file-list li').forEach(li => li.classList.remove('active'));
                const activeLi = document.getElementById(`file-${fileId}`);
                if (activeLi) activeLi.classList.add('active');

            } catch (err) {
                console.error(err);
                setStatus('error', 'Load Failed: ' + (err.result?.error?.message || err.message));
            }
        }

        async function saveDriveFile(content) {
            if (!currentFileId) return;

            isSaving = true;
            setStatus('saving', 'Saving...');

            try {
                // Restore original image paths
                const originalContent = restoreImages(content);

                // Re-attach frontmatter
                const finalContent = currentFrontmatter + originalContent;

                if (isTestMode && testOverrides.updateFile) {
                    await testOverrides.updateFile(currentFileId, finalContent);
                } else {
                    await gapi.client.request({
                        path: `/upload/drive/v3/files/${currentFileId}`,
                        method: 'PATCH',
                        params: { uploadType: 'media' },
                        body: finalContent
                    });
                }

                setStatus('saved', 'Saved to Drive');
            } catch (err) {
                console.error(err);
                setStatus('error', 'Save Failed');
            } finally {
                isSaving = false;
            }
        }

        // Helper to fetch blob (wrapper for easy mocking)
        async function fetchBlob(url, headers) {
            if (isTestMode && testOverrides.fetchBlob) {
                return testOverrides.fetchBlob(url, headers);
            }
            const resp = await fetch(url, { headers });
            if (!resp.ok) throw new Error('Fetch failed');
            return resp.blob();
        }

        // --- Image Handling Helpers ---
        let imageMap = new Map(); // blobUrl -> originalPath

        // Recursively find file ID by path (e.g. "Assets/img.png") starting from parentId
        async function findFileIdByPath(parentId, path) {
            const parts = path.split('/');
            let currentId = parentId;

            for (let i = 0; i < parts.length; i++) {
                const name = parts[i];
                const isLast = i === parts.length - 1;
                const safeName = name.replace(/'/g, "\\'");

                // For folders, we need distinct query? strictly speaking, files and folders are just files with mimeTypes.
                // But generally we just look for name and parent.
                const q = `'${currentId}' in parents and name = '${safeName}' and trashed = false`;

                const listResp = (isTestMode && testOverrides.listFiles)
                    ? await testOverrides.listFiles(q)
                    : await gapi.client.drive.files.list({
                        q: q,
                        fields: 'files(id, name, mimeType)',
                        pageSize: 1
                    });

                const files = listResp.result.files;
                if (!files || files.length === 0) {
                    console.warn(`[MilkdownImage] Path segment not found: ${name} in ${currentId}`);
                    return null;
                }

                // If duplicates, take first. Ideally prioritize folders if we are in middle of path.
                // If not lsast, we expect a folder.
                let match = files[0];
                if (!isLast) {
                    match = files.find(f => f.mimeType === 'application/vnd.google-apps.folder') || files[0];
                }

                currentId = match.id;
            }
            return currentId;
        }

        async function resolveImages(markdown, parentId) {
            imageMap.clear();
            const regex = /!\[([^\]]*)\]\(([^)]+)\)/g;
            let match;
            const updates = [];

            // 1. Find all local images
            while ((match = regex.exec(markdown)) !== null) {
                const [fullMatch, alt, src] = match;
                if (!src.startsWith('http') && !src.startsWith('data:')) {
                    updates.push({ fullMatch, alt, src });
                }
            }

            if (updates.length === 0) return markdown;

            // 2. Fetch blobs for each unique local image
            // We use a Set to avoid fetching same image twice
            const uniqueSrcs = [...new Set(updates.map(u => u.src))];
            const urlMap = {}; // src -> blobUrl

            console.log('[MilkdownImage] Resolving images in parent:', parentId, uniqueSrcs);
            if (!parentId) {
                console.warn('[MilkdownImage] No parent ID found, cannot resolve sibling images.');
                return markdown;
            }

            await Promise.all(uniqueSrcs.map(async (src) => {
                try {
                    // Resolve nested path
                    const fileId = await findFileIdByPath(parentId, src);

                    if (fileId) {
                        console.log(`[MilkdownImage] Found ${src} -> ${fileId}`);

                        // Fetch content as blob
                        const token = (isTestMode ? 'mock-token' : gapi.client.getToken().access_token);

                        const blob = await fetchBlob(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
                            'Authorization': `Bearer ${token}`
                        });

                        const blobUrl = URL.createObjectURL(blob);
                        urlMap[src] = blobUrl;
                        imageMap.set(blobUrl, src);
                    } else {
                        console.warn(`[MilkdownImage] Image not found in Drive: ${src}`);
                    }
                } catch (e) {
                    console.warn(`[MilkdownImage] Failed to load image ${src}`, e);
                }
            }));

            // 3. Replace in markdown
            let newMarkdown = markdown;
            updates.forEach(({ fullMatch, alt, src }) => {
                if (urlMap[src]) {
                    // Use replace with string to avoid regex special char issues in src
                    // But we must match the exact instance.
                    // To be safe, we rebuild the string or use global replace carefully.
                    // Since we iterate findings, naive replace might replace wrong instance if duplicates exist.
                    // But here we want to replace ALL instances of valid relative path with the blob.
                    // So global replace of the path is actually what we want.
                    // Caution: ensure we don't replace partial strings?
                    // simpler: replace the whole tag `![alt](src)` -> `![alt](blobUrl)`
                    const newTag = `![${alt}](${urlMap[src]})`;
                    newMarkdown = newMarkdown.split(fullMatch).join(newTag);
                }
            });

            return newMarkdown;
        }

        function restoreImages(markdown) {
            let newMarkdown = markdown;
            // Iterate map and replace blobUrls back to original
            for (const [blobUrl, originalSrc] of imageMap.entries()) {
                newMarkdown = newMarkdown.split(blobUrl).join(originalSrc);
            }
            return newMarkdown;
        }

        /*******************************************************
         * II. LOGIC & HELPERS
         *******************************************************/

        function renderFileList(files) {
            fileList.innerHTML = '';
            if (!files || files.length === 0) {
                fileList.innerHTML = '<li style="padding:20px; color:#999; text-align:center;">No Markdown files found.</li>';
                return;
            }

            files.forEach(file => {
                const li = document.createElement('li');
                li.id = `file-${file.id}`;
                li.textContent = file.name;
                li.onclick = () => loadDriveFile(file.id, file.name);
                fileList.appendChild(li);
            });
        }

        // Basic Frontmatter Parser (YAML-like)
        // Looks for --- at start, then next ---
        function parseFrontmatter(text) {
            // Normalize newlines
            const normalized = text.replace(/\r\n/g, '\n');
            const match = normalized.match(/^---\n([\s\S]*?)\n---\n/);

            if (match) {
                return {
                    frontmatter: match[0], // Keep the whole block including delimiters
                    body: normalized.substring(match[0].length)
                };
            }
            return { frontmatter: "", body: normalized };
        }

        function setStatus(cls, text) {
            statusSpan.className = `status-badge ${cls}`;
            statusSpan.textContent = text;
        }

        // Debounce
        function debounce(func, wait) {
            return function (...args) {
                clearTimeout(debounceTimer);
                setStatus('saving', 'Unsaved changes...');
                debounceTimer = setTimeout(() => func.apply(this, args), wait);
            };
        }

        const debouncedSave = debounce((content) => {
            saveDriveFile(content);
        }, 2000); // 2 second delay

        // Search Listener
        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                fileList.innerHTML = '<li style="padding:20px; color:#999; text-align:center;">Searching...</li>';
                listRecentFiles(e.target.value);
            }, 500);
        });

        /*******************************************************
         * III. MILKDOWN EDITOR
         *******************************************************/

        async function createEditor(content) {
            if (isTestMode && testOverrides.createEditor) return testOverrides.createEditor(content);

            editorInstance = await Editor.make()
                .config((ctx) => {
                    ctx.set(rootCtx, document.querySelector('#app'));
                    ctx.set(defaultValueCtx, content);
                    ctx.set(editorViewOptionsCtx, { editable: () => true });

                    // Listener for autosave
                    ctx.get(listenerCtx).markdownUpdated((ctx, markdown) => {
                        // Only save if we have a file loaded
                        if (currentFileId) {
                            debouncedSave(markdown);
                        }
                    });
                })
                .use(nord)
                .use(commonmark)
                .use(listener)
                .create();
        }

        async function destroyEditor() {
            if (editorInstance) {
                document.querySelector('#app').innerHTML = '';
                editorInstance = null;
            }
            fileNameSpan.textContent = "";
            currentFileId = null;
            currentFrontmatter = "";
            setStatus('ready', '');
        }

        /*******************************************************
         * IV. TESTING (QUNIT)
         *******************************************************/
        if (isTestMode && window.QUnit) {
            document.body.classList.add('testing');

            QUnit.module('Frontmatter Logic', () => {
                QUnit.test('parseFrontmatter separates YAML from body', assert => {
                    const original = "---\ntitle: test\n---\n# Header\nContent";
                    const { frontmatter, body } = parseFrontmatter(original);
                    assert.equal(frontmatter.trim(), "---\ntitle: test\n---", "Frontmatter captured");
                    assert.equal(body.trim(), "# Header\nContent", "Body captured");
                });

                QUnit.test('parseFrontmatter handles no frontmatter', assert => {
                    const original = "# Just Content";
                    const { frontmatter, body } = parseFrontmatter(original);
                    assert.equal(frontmatter, "", "Empty frontmatter");
                    assert.equal(body, original, "Body matches original");
                });
            });

            QUnit.module('UI & List', hooks => {
                hooks.beforeEach(() => {
                    fileList.innerHTML = '';
                });

                QUnit.test('renderFileList creates list items', assert => {
                    const files = [
                        { id: '1', name: 'File1.md' },
                        { id: '2', name: 'File2.md' }
                    ];
                    renderFileList(files);
                    assert.equal(fileList.children.length, 2);
                    assert.equal(fileList.children[0].textContent, 'File1.md');
                });

                QUnit.test('renderFileList handles empty list', assert => {
                    renderFileList([]);
                    assert.ok(fileList.textContent.includes('No Markdown files'));
                });
            });

            QUnit.module('Drive Interaction', hooks => {
                let savedListFiles, savedGetFile, savedUpdateFile;

                hooks.beforeEach(() => {
                    savedListFiles = testOverrides.listFiles;
                    savedGetFile = testOverrides.getFile;
                    savedUpdateFile = testOverrides.updateFile;
                });

                hooks.afterEach(() => {
                    testOverrides.listFiles = savedListFiles;
                    testOverrides.getFile = savedGetFile;
                    testOverrides.updateFile = savedUpdateFile;
                    currentFileId = null;
                    if (debounceTimer) clearTimeout(debounceTimer);
                });

                QUnit.test('listRecentFiles calls API with correct query', async assert => {
                    const done = assert.async();
                    testOverrides.listFiles = async (q) => {
                        assert.ok(q.includes("name contains '.md'"), "Query filters for markdown");
                        assert.ok(q.includes("trashed = false"), "Query excludes trash");
                        done();
                        return { result: { files: [] } };
                    };
                    await listRecentFiles();
                });

                QUnit.test('loadDriveFile parses frontmatter and sets editor', async assert => {
                    const done = assert.async();
                    const mockId = '123';
                    const mockContent = "---\nmeta: true\n---\n# Body";

                    testOverrides.getFileMeta = async (id) => {
                        assert.equal(id, mockId);
                        return { result: { parents: ['folder1'], name: 'Test.md' } };
                    };

                    testOverrides.getFile = async (id) => {
                        assert.equal(id, mockId);
                        return { body: mockContent };
                    };

                    // Allow images to skip if no files found
                    testOverrides.listFiles = async () => ({ result: { files: [] } });

                    testOverrides.createEditor = async (content) => {
                        assert.equal(content, "# Body", "Editor received only body");
                        assert.equal(currentFrontmatter, "---\nmeta: true\n---\n", "Frontmatter stored globally");
                        done();
                    };

                    await loadDriveFile(mockId, 'Test.md');
                });

                QUnit.test('saveDriveFile re-attaches frontmatter', async assert => {
                    const done = assert.async();

                    // Setup internal state
                    currentFileId = '123';
                    currentFrontmatter = "---Header---\n";
                    const newContent = "New Body";

                    testOverrides.updateFile = async (id, content) => {
                        assert.equal(id, '123');
                        assert.equal(content, "---Header---\nNew Body", "Frontmatter prepended to update");
                        // check UI
                        assert.ok(statusSpan.className.includes('saving'), 'Status is saving during op');
                        done();
                    };

                    await saveDriveFile(newContent);
                    assert.ok(statusSpan.className.includes('saved'), 'Status becomes saved');
                });
            });

            QUnit.module('Image Handling', hooks => {
                hooks.beforeEach(() => {
                    imageMap = new Map();
                });

                QUnit.test('resolveImages replaces local paths with blobs', async assert => {
                    const done = assert.async();
                    const markdown = "![img1](test.png) ![img2](assets/icon.png)";
                    const mockParent = "folder123";

                    // Mock List API with nested logic
                    testOverrides.listFiles = async (q) => {
                        // 1. Root level test.png
                        if (q.includes(`'folder123' in parents`) && q.includes(`name = 'test.png'`)) {
                            return { result: { files: [{ id: 'file1', name: 'test.png' }] } };
                        }

                        // 2. assets folder search
                        if (q.includes(`'folder123' in parents`) && q.includes(`name = 'assets'`)) {
                            return { result: { files: [{ id: 'folder-assets', name: 'assets', mimeType: 'application/vnd.google-apps.folder' }] } };
                        }

                        // 3. icon.png in assets folder
                        if (q.includes(`'folder-assets' in parents`) && q.includes(`name = 'icon.png'`)) {
                            return { result: { files: [{ id: 'file-icon', name: 'icon.png' }] } };
                        }

                        return { result: { files: [] } };
                    };

                    // Mock Fetch
                    testOverrides.fetchBlob = async (url) => {
                        if (url.includes('files/file1') || url.includes('files/file-icon')) {
                            return new Blob(['fake-image']);
                        }
                        throw new Error("404");
                    };

                    // Stub createObjectURL
                    const originalCreateObjectUrl = URL.createObjectURL;
                    URL.createObjectURL = (blob) => "blob:test-url";

                    try {
                        const result = await resolveImages(markdown, mockParent);

                        // Check test.png
                        assert.ok(result.includes("![img1](blob:test-url)"), "img1 (flat) replaced");
                        // Check assets/icon.png
                        assert.ok(result.includes("![img2](blob:test-url)"), "img2 (nested) replaced");

                        // Verify Map
                        assert.equal(imageMap.get("blob:test-url"), "assets/icon.png", "Map stored correct reverse path for nested");

                    } finally {
                        URL.createObjectURL = originalCreateObjectUrl;
                        done();
                    }
                });

                QUnit.test('restoreImages reverts blobs to original paths', assert => {
                    imageMap.set("blob:abc", "original.png");
                    const input = "![test](blob:abc)";
                    const result = restoreImages(input);
                    assert.equal(result, "![test](original.png)");
                });
            });
        }
    </script>
</body>

</html>